package  {		import flash.media.Camera;	import flash.media.Video;	import flash.events.Event;	import flash.display.Bitmap;	import flash.display.FrameLabel;	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.display.Shader;	import flash.geom.Rectangle;	import flash.display.Shape;	import flash.geom.ColorTransform;	import flash.filters.ColorMatrixFilter;		public class RedTracker {				//var threshold:uint = 0xFF55FFFF;		var threshold:uint = 0xFF33FFFF;				var checkDistance:uint = 4;				private var camW : uint;		private var camH : uint;				private var cam:Camera;		private var vid:Video;				public var vid_current:BitmapData;				public function RedTracker(camera:Camera, cameraWidth:uint, cameraHeight:uint) {						camW = cameraWidth;			camH = cameraHeight;						cam = camera;			vid = new Video(camW, camH);			vid.attachCamera(camera);						vid_current = new BitmapData(camW, camH);					}				public function track() : Point {						var fg:uint = 0xFFFFFFFF;			var bg:uint = 0xFF000000;						if ( !cam.muted ) {								vid_current.draw(vid);								// colour matrix hacking				// format is red, green, blue, alpha, offset				var matrix:Array = new Array();				matrix=matrix.concat([2,-1,-1,0,0]);// red				matrix=matrix.concat([-2,0,0,0,0]);// green				matrix=matrix.concat([-2,0,0,0,0]);// blue				matrix=matrix.concat([0,0,0,1,0]);// alpha				var my_filter:ColorMatrixFilter=new ColorMatrixFilter(matrix);				vid_current.applyFilter(vid_current, vid_current.rect, new Point(), my_filter);								vid_current.threshold(vid_current, vid_current.rect, new Point(), ">", threshold, 0xFFFFFFFF);				vid_current.threshold(vid_current, vid_current.rect, new Point(), "<", threshold, 0xFF000000);								var hingeRow:int = camH-1;				var hingeCol:int = -1;				var hinge:Point = new Point();								var vect = vid_current.getVector(vid_current.rect);								while ( (hingeRow >= checkDistance) && ((hingeCol=checkCollision(vect, camW, camH, hingeRow, checkDistance)) == -1))					hingeRow--;								if (hingeCol != -1)					return new Point(hingeCol, hingeRow);				else					return null;							} else {								return null;							}					}				private function checkCollision(image:Vector.<uint>, imageWidth:uint, imageHeight:uint, row:uint, checkDistance:uint) : int {						for (var col:uint = checkDistance; col < imageWidth - checkDistance; col++) {								var matches:uint = 0;								for (var c:uint = 0; c <= checkDistance; c++) {										if ( image[( (row - c) * imageWidth) + col] != 0xFF000000 )						matches++;										if ( image[( (row - c) * imageWidth) + (col - c)] != 0xFF000000 )						matches++;										if ( image[( (row - c) * imageWidth) + (col  + c)] != 0xFF000000 )						matches++;									}								if (matches >= 3.0 * checkDistance)					return col;							}						return -1;					}				public function disconnect() {						vid.attachCamera(null);					}			}	}